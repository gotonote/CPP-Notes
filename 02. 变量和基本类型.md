# 2. 变量和基本类型

## 2.1. 复合类型

复合类型 (compound type) 是指基于其他类型定义的类型. 最常见的是引用和指针.

引用即别名: 引用 (reference) 为对象起了另外一个名字, 引用类型引用 (refers to) 另外一种类型.

*   定义引用时, 程序把引用和它的初始值绑定在一起, 而不是将初始值拷贝给引用. 一旦初始化完成, 引用将和它的初始值对象一直绑定在一起. 因为无法令引用重新绑定到另外一个对象, 因此引用必须初始化.
    
*   因为引用不是一个对象, 所以不能定义引用的引用.
    

指针 (pointer) 是指向 (point to) 另外一种类型的复合类型.

*   指针无需在定义时赋初值.
    
*   指针本身就是一个对象, 允许对指针赋值和拷贝, 而且在指针的生命周期内它可以先后指向几个不同的对象.
    

表 2.1 指针与数组的区别

| **指针** | **数组** |
|------|------|
| 保存数据的地址  | 保存数据 |
| 间接访问数据，首先获得指针的内容，然后将其作为地址，从该地址中提取数据 | 直接访问数据 |
| 通常用于动态的数据结构 | 通常用于固定数目且数据类型相同的元素 |
| 通过malloc分配内存，free释放内存 | 隐式的分配和删除 |
| 通常指向匿名数据，操作匿名函数 | 自身即为数据名 |
| 指针取地址得到的是指针变量自身的地址 | 数据名取地址得到的是数组名所指元素的地址（数组的第一个元素的地址） |
| 指针能更改名字 | 数组是固定大小，数组一经定义，就不能改变数组名 |

## 2.2. const 限定符

### 2.2.1. 作用

*   修饰变量: 表明该变量的值不可以被改变.
    
*   修饰指针: 区分指向常量的指针和常量指针.
    
*   修饰引用: 用于形参, 既避免了拷贝, 又避免了函数对值的修改.
    
*   修饰成员函数: 表示函数不能修改成员变量 (实际上是修饰 this 指针)
    

补充:

*   对于局部对象, 常量存放在栈区;
    
*   对于全局对象, 常量存放在全局 / 静态存储区;
    
*   对于字面值常量, 常量存放在常量存储区 (代码段).
    

### 2.2.2. 指向常量的指针 VS 常量指针

参考 C++ Primer 2.4.2 指针和`const`:

*   指向常量的指针 (pointer to const):
    
*   具有只能够读取内存中数据, 却不能够修改内存中数据的属性的指针 (底层 const).
    
*   `const int * p`; 或者`int const * p`;
    
*   常量指针 (const pointer): 常量指针是指指针所指向的位置不能改变, 即指针本身是一个常量 (顶层 const), 但是指针所指向的内容可以改变.
    
*   常量指针必须在声明的同时对其初始化, 不允许先声明一个指针常量随后再对其赋值, 这和声明一般的常量是一样的.
    
*   `int * const p = &a;`
    

### 2.2.3. cosntexpr

*   常量表达式 (const expression) 是指值不会改变并且在编译过程就能得到计算结果的表达式.
    
*   一般来说, 如果认定变量是一个常量表达式, 那就把它声明成`constexpr`类型.
    
*   一个`constexpr`指针的初始值必须是`nullptr`或者`0`, 或者是存储于某个固定地址中的对象.
    
*   constexpr 函数是指能用于常量表达式的函数.
    
*   函数的返回类型及所有的形参的类型都得是字面值类型.
    
*   函数体中必须有且只有一条 return 语句.
    

### 2.2.4. #define VS const

| **#define** | **const** |
|---------|-------|
| 宏定义，相当于字符替换 | 常量声明 |
| 预处理器处理 | 编译器处理 |
| 无类型安全检查 | 有类型安全检查 |
| 不分配内存 | 要分配内存 |
| 存储在代码段(.text) | 存储在数据段(.data, .bbs)|
| 可通过 #undef 取消| 不可取消 |
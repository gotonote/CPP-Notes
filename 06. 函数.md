# 6. 函数

## 6.1. 函数基础

### 6.1.1. 形参和实参

实参是形参的初始值.

### 6.1.2. static

*   修饰局部变量: 使得被修饰的变量成为静态变量, 存储在静态区. 存储在静态区的数据生命周期与程序相同, 在 main 函数之前初始化, 在程序退出时销毁. 默认初始化为 0.
    
*   修饰全局变量: 限制了链接属性, 使得全局变量只能在声明它的源文件中访问.
    
*   修饰普通函数: 使得函数只能在声明它的源文件中访问.
    
*   修饰类的成员变量和成员函数: 使其只属于类而不是属于某个对象. 对多个对象来说, 静态数据成员只存储一处, 供所有对象共用.
    
*   静态成员调用格式 <类名>::< 静态成员 >
    
*   静态成员函数调用格式 <类名>::< 静态成员函数名 >(< 参数表 >)
    

## 6.2. 参数传递

指针参数传递本质上是值传递, 它所传递的是一个地址值.

一般情况下, 输入用传值或者传 const reference. 输出传引用 (或者指针).

## 6.3. 内联函数

### 6.3.1. 使用

将函数指定为内联函数 (`inlin`e), 通常就是将它在每个调用点上 "内联地" 展开.

一般来说, 内联机制用于优化规模较小 (Google C++ Style 建议 10 行以下)、流程直接、频繁调用的函数.

在类声明中定义的函数, 除了虚函数的其他函数都会自动隐式地当成内联函数.

### 6.3.2. 编译器对 inline 函数的处理步骤

*   将 inline 函数体复制到 inline 函数调用点处;
    
*   为所用 inline 函数中的局部变量分配内存空间;
    
*   将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中;
    
*   如果 inline 函数有多个返回点, 将其转变为 inline 函数代码块末尾的分支 (使用 GOTO).
    

### 6.3.3. 优缺点

优点:

1.  内联函数同宏函数一样将在被调用处进行代码展开, 省去了参数压栈、栈帧开辟与回收, 结果返回等, 从而提高程序运行速度.
    
2.  内联函数相比宏函数来说, 在代码展开时, 会做安全检查或自动类型转换 (同普通函数), 而宏定义则不会.
    
3.  在类中声明同时定义的成员函数, 自动转化为内联函数, 因此内联函数可以访问类的成员变量, 宏定义则不能.
    
4.  内联函数在运行时可调试, 而宏定义不可以.
    

缺点:

1.  代码膨胀. 内联是以代码膨胀 (复制) 为代价, 消除函数调用带来的开销. 如果执行函数体内代码的时间, 相比于函数调用的开销较大, 那么效率的收获会很少. 另一方面, 每一处内联函数的调用都要复制代码, 将使程序的总代码量增大, 消耗更多的内存空间.
    
2.  inline 函数无法随着函数库升级而升级. inline 函数的改变需要重新编译, 不像 non-inline 可以直接链接.
    
3.  是否内联, 程序员不可控. 内联函数只是对编译器的建议, 是否对函数内联, 决定权在于编译器.
    

## 6.4. 返回类型和 return 语句

调用一个返回引用的函数得到左值, 其他返回类型得到右值.

## 6.5. 特殊用途语言特性

### 6.5.1. 调试帮助

`assert`是一种预处理器宏. 使用一个表达式作为它的条件:

```CPP
assert(expr);
```

`首先对`expr`求值, 如果表达式为`false`.` assert 输出信息并终止程序的执行. 如果表达式为`true`. `assert`什么也不做.

## 6.6. 函数指针

函数指针指向的是函数而非对象. 和其他指针一样, 函数指针指向某种特定类型. 函数的类型由它的返回类新和形参共同决定, 与函数名无关.

C 在编译时, 每一个函数都有一个入口地址, 该入口地址就是函数指针所指向的地址.

有了指向函数的指针变量后, 可用该指针变量调用函数, 就如同用指针变量可引用其他类型变量一样

用途: 调用函数和做函数的参数, 比如回调函数.

```CPP
char * fun(char * p)  {…}  // 函数fun
char * (*pf)(char * p);    // 函数指针pf
pf = fun;                  // 函数指针pf指向函数fun
pf(p);                     // 通过函数指针pf调用函数fun
```

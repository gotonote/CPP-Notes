# 7. 类

## 7.1. 定义抽象数据类型

### 7.1.1. this 指针

*   this 指针是一个隐含于每一个非静态成员函数中的特殊指针. 它指向调用该成员函数的那个对象.
    
*   this 的目的总是指向 "这个" 对象, 所以 this 是一个常量指针, 被隐含地声明为: ClassName * const this, 这意味着不能给 this 指针赋值;
    
*   在 ClassName 类的 const 成员函数中, this 指针的类型为: const ClassName* const, 这说明不能对 this 指针所指向对象进行修改.
    
*   当对一个对象调用成员函数时, 编译程序先将对象的地址赋给 this 指针, 然后调用成员函数, 每次成员函数存取数据成员时, 都隐式使用 this 指针.
    
*   当一个成员函数被调用时, 自动向它传递一个隐含的参数, 该参数是一个指向这个成员函数所在的对象的指针.
    
*   this 并不是一个常规变量, 而是个右值, 所以不能取得 this 的地址 (不能 & this).
    
*   在以下场景中, 经常需要显式引用 this 指针:
    
    *   为实现对象的链式引用;
        
    *   为避免对同一对象进行赋值操作;
        
    *   在实现一些数据结构时, 如 list
    
### 7.1.2. 拷贝函数

*   C++ 深拷贝与浅拷贝
    
*   在未定义显示拷贝构造函数的情况下, 系统会调用默认的拷贝函数——即浅拷贝, 它能够完成成员的一一复制. 当数据成员中没有指针时, 浅拷贝是可行的; 但当数据成员中有指针时, 如果采用简单的浅拷贝, 则两类中的两个指针将指向同一个地址, 当对象快结束时, 会调用两次析构函数, 而导致指针悬挂现象, 所以此时必须采用深拷贝.
    
*   深拷贝与浅拷贝的区别就在于深拷贝会在堆内存中另外申请空间来储存数据, 从而也就解决了指针悬挂的问题. 简而言之, 当数据成员中有指针时, 必须要用深拷贝.
    

### 7.1.3. 析构函数

(TODO: 整理析构函数的特性)

*   析构顺序与构造函数的构造顺序相反.
    
*   当对象结束生命周期时, 系统会自动执行析构函数.
    
*   析构函数声明时在函数名前加取反符~, 不带任何参数, 也没有返回值.
    
*   如果用户没有声明析构函数, 系统会自动生成一个缺省的析构函数.
    
*   如果类中有指针, 且在使用的过程中动态申请了内存, 那么需要显示构造析构函数, 在销毁类之前, 释放掉申请的内存空间, 避免内存泄漏.
    

## 7.2. 访问控制与封装

### 7.2.1. public/private/protected

*   定义在 public 说明符之后的成员在整个程序内可被访问, public 成员内定的接口.
    
*   定义在 private 说明符之后的成员可以被类的成员函数访问, 但是不能被使用该类的代码访问, private 部分封装了 (即隐藏了) 类的实现细节.
    
*   基类希望它的派生类有权访问该成员, 同时禁止其他用户访问. 我们用受保护的 (protected) 访问运算符说明这样的成员.
    

### 7.2.2. struct 和 class 的区别

*   struct 与 class 定义的唯一区别就是默认的访问权限 (struct 默认是 public, class 默认是 private).
    
*   使用习惯上, 只有少量成员变量的的用 struct 定义.
    

### 7.2.3. 友元

类可以允许其他类或者函数访问它的非公有成员, 方法是令其他类或者函数成为它的有元 (friend).

## 7.3. 构造函数再探

### 7.3.1. 初始化顺序

成员变量的初始化顺序与它们在类定义中的出现顺序一致: 构造函数初始值列表中初始值的前后位置关系不会影响

### 7.3.2. explicit

*   用于类的构造函数, 阻止其执行隐式类型转换, 但是仍可以被用来进行显式类型转换.